#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#define max(a,b) a<b?b:a
#define min(a,b) a<b?a:b
#define POW2(a)  a*a
#define ROOP(i,n) for(i = 0;i < n;i++)
#define _USE_MATH_DEFINES

typedef struct POINT{
	double x;
	double y;
}POINT;
typedef struct LINE{
	POINT s;//start point
	POINT e;//end point
}LINE;
typedef struct COMPLEX{
	double r;//?????¢
	double q;//????§???????theta
}COMPLEX;

//POINT????????????
void print_p(POINT a){
	printf("(%lf,%lf)\n",a.x,a.y);
}

//LINE????????????
void print_l(LINE a){
	printf("(%lf,%lf) -> (%lf,%lf)\n",(a.s).x,(a.s).y,(a.e).x,(a.e).y);
}

//COMPLEX????????????
void print_c(COMPLEX a){
	printf("(%lf,%lf)\n",a.r,a.q);
}

//????????????????????¢?????????
double norm2(POINT a){
	return POW2(a.x)+POW2(a.y);
}

//????????????????????¢
double norm(POINT a){
	return sqrt(norm2(a));
}

//a->b?????´??§???????????????
POINT make_vec(POINT a,POINT b){
	b.x -= a.x;
	b.y -= a.y;
	return b;
}

//2???a,b???????????¢
double distance(POINT a,POINT b){
	return norm(make_vec(a,b));
}

//??´??§????????????
POINT sum_vec(POINT a,POINT b){
	a.x += b.x;
	a.y += b.y;
	return a;
}

//??´??§????????????
//mkae_vec??¨?????£??????????????¨???????????????
//??????????????????
POINT dif_vec(POINT a,POINT b){
	a.x -= b.x;
	a.y -= b.y;
	return a;
}

//??´??§????????????????????????
POINT scalar_vec(POINT a,double k){
	a.x *= k;
	a.y *= k;
	return a;
}

//???????????????
POINT minus_vec(POINT a){
	return scalar_vec(a,-1.0);
}

//??????
double dot(POINT a,POINT b){
	return a.x*b.x + a.y*b.y;
}

//??????
double cross(POINT a,POINT b){
	return a.x*b.y - a.y*b.x;
}

//AP:PB=t:s??¨?????????????±???????
//k, 0:??????, 1:??????
//* t:(1-t)??§???????????£??????????????£????????????????????????????????????????????????????????¨?????£???
POINT division(POINT a,POINT b,double t,double s,int k){
	double tmp = t + s * (1 - k*2);
	a.x += (make_vec(a,b)).x / tmp * t;
	a.y += (make_vec(a,b)).y / tmp * t;
	return a;
}

//???p????????´???a?????????????????????????¶??????????
POINT perpendicular(LINE a,POINT p){
	POINT ps = make_vec(p,a.s);
	POINT pe = make_vec(p,a.e);
	double t = norm2(ps) - dot(ps,pe);
	double s = norm2(pe) - dot(ps,pe);
	return division(a.s,a.e,t,s,0);
}

//??´???a???????????????p??¨????§°???????????????
POINT reflection(LINE a,POINT p){
	POINT h = perpendicular(a,p);
	return sum_vec(h,make_vec(p,h));
}

//* ????§???¢?????????
int inclusion(POINT a[],int n,POINT p){
	int ans = 0;
	int i;
	POINT g[n+1];
	double w,rad = 0.0;

	for(i = 0;i < n;i++){
		g[i] = a[i];
	}
	g[n] = g[0];

	for(i = 0;i < n;i++){
		if(g[i].x == p.x && g[i].y == p.y){
			return ans = 1;
		}
	}
	for(i = 0;i < n;i++){
		w = atan2(cross(make_vec(p,g[i]),make_vec(p,g[i+1])),
				dot(make_vec(p,g[i]),make_vec(p,g[i+1])));
		rad += w;
		if(fabs(w - M_PI) <= 0.000001 ||
			 fabs(w + M_PI) <= 0.000001)
			return ans = 1;
	}
	if(fabs(rad - M_PI*2)<=0.000001){//2??
		return ans = 2;//in!
	}
	return ans;
}

// a.s, a.e, p?????????????????????
// ???????¨???????????????????????????????  1
// ????¨?????????????????????????????????? -1
// p, a.s, a.e????????????????????? 2
// a.s, a.e, p?????????????????????-2
// ???p?????´???a???????????????????????? 0
int ccw(LINE a,POINT p){
	int cls = cross(make_vec(a.s,a.e),make_vec(a.s,p));
	if(cls > 0){
		return  1;
	}else if(cls < 0){
		return -1;
	}else if(dot(make_vec(a.s,a.e),make_vec(a.s,p)) < 0){
		return  2;
	}else if(dot(make_vec(a.e,a.s),make_vec(a.e,p)) < 0){
		return -2;
	}else{
		return  0;
	}
}

// ??????????????????
int parallel(LINE a,LINE b){
	if(!cross(make_vec(a.s,a.e),make_vec(b.s,b.e)))
		return 1;
	else
		return 0;
}

// ?????´????????????
int orthogonal(LINE a,LINE b){
	if(!dot(make_vec(a.s,a.e),make_vec(b.s,b.e)))
		return 1;
	else
		return 0;
}

// ??????a,b???????????????????????????
int intersection(LINE a,LINE b){
	if(ccw(a,b.s)*ccw(a,b.e) <= 0 &&
	   ccw(b,a.s)*ccw(b,a.e) <= 0)
		return 1;
	return 0;
}

//??????a,b?????????
POINT cross_point(LINE a,LINE b){
	double c1 = cross(make_vec(a.s,b.s),make_vec(a.s,b.e));
	double c2 = cross(make_vec(a.e,b.s),make_vec(a.e,b.e));
	return division(a.s,a.e,fabs(c1),fabs(c2),0);
}

//??´???a??¨???p????????¢
double distanceLP(LINE a,POINT p){
	if(ccw(a,p) ==  2)
		return norm(make_vec(a.s,p));
	if(ccw(a,p) == -2)
		return norm(make_vec(a.e,p));
	return norm(make_vec(perpendicular(a,p),p));
}

//??´???a??¨??´???b????????¢
double distanceLL(LINE a,LINE b){
	double a1,a2,a3,a4;
	if(intersection(a,b) == 1)
		return 0.0000000000;
	a1 = distanceLP(a,b.s);
	a2 = distanceLP(a,b.e);
	a3 = distanceLP(b,a.s);
	a4 = distanceLP(b,a.e);
	a1 = min(a1,a2);
	a3 = min(a3,a4);
	a1 = min(a1,a3);
	return a1;
}

int main(){
	LINE a,b;
	int k;
	POINT p;
	scanf("%d",&k);
	while(k--){
		scanf("%lf%lf%lf%lf",&a.s.x,&a.s.y,&a.e.x,&a.e.y);
		scanf("%lf%lf%lf%lf",&b.s.x,&b.s.y,&b.e.x,&b.e.y);
		printf("%.10lf\n",distanceLL(a,b));
	}
/*
	POINT a,b,q;
	double t,s;

	scanf("%lf%lf%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y,&t,&s);

	q = division(a,b,t,s,0);
	printf("%lf %lf\n",q.x,q.y);
*/
/*
	LINE a;
	POINT b;
	int k;
	char s[5][100]={{"ONLINE_FRONT"},{"CLOCKWISE"},{"ON_SEGMENT"},{"COUNTER_CLOCKWISE"},{"ONLINE_BACK"}};
	
	scanf("%lf%lf%lf%lf%d",&a.s.x,&a.s.y,&a.e.x,&a.e.y,&k);
	while(k--){
		scanf("%lf%lf",&b.x,&b.y);
		printf("%s\n",s[ccw(a,b)+2]);
	}
*/
/*
	POINT a,b;
	int k;
	while(1){
		scanf("%lf%lf%lf%lf%d",&a.x,&a.y,&b.x,&b.y,&k);
		print_p(sum_vec(a,b));
		print_p(dif_vec(a,b));
		print_p(scalar_vec(a,k));
		print_p(minus_vec(a));
	}
*/
/*
	POINT a,b;
	while(1){
		scanf("%lf%lf%lf%lf",&a.x,&a.y,&b.x,&b.y);
		printf("%lf\n",distance(a,b));
	}
*/
/*
	int i,m,n;
	POINT g[100];//n
	POINT q;//m
	int ans = 0;

	scanf("%d",&n);
	for(i = 0;i < n;i++){
		scanf("%lf%lf",&g[i].x,&g[i].y);
	}
	scanf("%d",&m);
	for(i = 0;i < m;i++){
		scanf("%lf%lf",&q.x,&q.y);
		ans = inclusion(g,n,q);
		printf("%d\n",ans);
	}
*/
	return 0;
}